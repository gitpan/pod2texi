@node perlcall, Top, perlguts, Top
@unnumbered Perl calling conventions from C


@unnumberedsec NAME

perlcall - Perl calling conventions from C

@unnumberedsec DESCRIPTION

The purpose of this document is to show you how to call Perl subroutines
directly from C, i.e. how to write @emph{callbacks}.

Apart from discussing the C interface provided by Perl for writing
callbacks the document uses a series of examples to show how the
interface actually works in practice.  In addition some techniques for
coding callbacks are covered.

Examples where callbacks are necessary include

@itemize @bullet
@item An Error Handler

You have created an XSUB interface to an application@'s C API.

A fairly common feature in applications is to allow you to define a C
function that will be called whenever something nasty occurs. What we
would like is to be able to specify a Perl subroutine that will be
called instead.

@item An Event Driven Program

The classic example of where callbacks are used is when writing an
event driven program like for an X windows application.  In this case
you register functions to be called whenever specific events occur,
e.g. a mouse button is pressed, the cursor moves into a window or a
menu item is selected.

@end itemize
Although the techniques described here are applicable when embedding
Perl in a C program, this is not the primary goal of this document.
There are other details that must be considered and are specific to
embedding Perl. For details on embedding Perl in C refer to
@xref{perlembed,Perlembed},.

Before you launch yourself head first into the rest of this document,
it would be a good idea to have read the following two documents -
@xref{perlxs,Perlxs}, and @xref{perlguts,Perlguts},.

@unnumberedsec THE PERL_CALL FUNCTIONS

Although this stuff is easier to explain using examples, you first need
be aware of a few important definitions.

Perl has a number of C functions that allow you to call Perl
subroutines.  They are

@example
I32 perl_call_sv(SV* sv, I32 flags) ;
I32 perl_call_pv(char *subname, I32 flags) ;
I32 perl_call_method(char *methname, I32 flags) ;
I32 perl_call_argv(char *subname, I32 flags, register char **argv) ;
@end example

The key function is perl_call_sv.  All the other functions are
fairly simple wrappers which make it easier to call Perl subroutines in
special cases. At the end of the day they will all call perl_call_sv
to actually invoke the Perl subroutine.

All the @emph{perl_call_*} functions have a @code{flags} parameter which is
used to pass a bit mask of options to Perl.  This bit mask operates
identically for each of the functions.  The settings available in the
bit mask are discussed in @samp{FLAG VALUES} in this node.

Each of the functions will now be discussed in turn.

@table @asis
@item perl_call_sv
perl_call_sv takes two parameters, the first, @code{sv}, is an SV*.
This allows you to specify the Perl subroutine to be called either as a
C string (which has first been converted to an SV) or a reference to a
subroutine. The section, Using perl_call_sv, shows how you can make
use of perl_call_sv.

@item perl_call_pv
The function, perl_call_pv, is similar to perl_call_sv except it
expects its first parameter to be a C char* which identifies the Perl
subroutine you want to call, e.g. @code{perl_call_pv("fred", 0)}.  If the
subroutine you want to call is in another package, just include the
package name in the string, e.g. @code{"pkg::fred"}.

@item perl_call_method
The function perl_call_method is used to call a method from a Perl
class.  The parameter @code{methname} corresponds to the name of the method
to be called.  Note that the class that the method belongs to is passed
on the Perl stack rather than in the parameter list. This class can be
either the name of the class (for a static method) or a reference to an
object (for a virtual method).  See @xref{perlobj,Perlobj}, for more information on
static and virtual methods and @samp{Using perl_call_method} in this node for an example
of using perl_call_method.

@item perl_call_argv
perl_call_argv calls the Perl subroutine specified by the C string
stored in the @code{subname} parameter. It also takes the usual @code{flags}
parameter.  The final parameter, @code{argv}, consists of a NULL terminated
list of C strings to be passed as parameters to the Perl subroutine.
See Using perl_call_argv.

@end table
All the functions return an integer. This is a count of the number of
items returned by the Perl subroutine. The actual items returned by the
subroutine are stored on the Perl stack.

As a general rule you should @emph{always} check the return value from
these functions.  Even if you are expecting only a particular number of
values to be returned from the Perl subroutine, there is nothing to
stop someone from doing something unexpected - don@'t say you haven@'t
been warned.

@unnumberedsec FLAG VALUES

The @code{flags} parameter in all the @emph{perl_call_*} functions is a bit mask
which can consist of any combination of the symbols defined below,
OR@'ed together.

@unnumberedsubsec G_SCALAR

Calls the Perl subroutine in a scalar context.  This is the default
context flag setting for all the @emph{perl_call_*} functions.

This flag has 2 effects:

@enumerate
@item 
It indicates to the subroutine being called that it is executing in a
scalar context (if it executes wantarray the result will be false).

@item 
It ensures that only a scalar is actually returned from the subroutine.
The subroutine can, of course,  ignore the wantarray and return a
list anyway. If so, then only the last element of the list will be
returned.

@end enumerate
The value returned by the @emph{perl_call_*} function indicates how many
items have been returned by the Perl subroutine - in this case it will
be either 0 or 1.

If 0, then you have specified the G_DISCARD flag.

If 1, then the item actually returned by the Perl subroutine will be
stored on the Perl stack - the section Returning a Scalar shows how
to access this value on the stack.  Remember that regardless of how
many items the Perl subroutine returns, only the last one will be
accessible from the stack - think of the case where only one value is
returned as being a list with only one element.  Any other items that
were returned will not exist by the time control returns from the
@emph{perl_call_*} function.  The section @emph{Returning a list in a scalar
context} shows an example of this behaviour.

@unnumberedsubsec G_ARRAY

Calls the Perl subroutine in a list context.

As with G_SCALAR, this flag has 2 effects:

@enumerate
@item 
It indicates to the subroutine being called that it is executing in an
array context (if it executes wantarray the result will be true).

@item 
It ensures that all items returned from the subroutine will be
accessible when control returns from the @emph{perl_call_*} function.

@end enumerate
The value returned by the @emph{perl_call_*} function indicates how many
items have been returned by the Perl subroutine.

If 0, then you have specified the G_DISCARD flag.

If not 0, then it will be a count of the number of items returned by
the subroutine. These items will be stored on the Perl stack.  The
section Returning a list of values gives an example of using the
G_ARRAY flag and the mechanics of accessing the returned items from the
Perl stack.

@unnumberedsubsec G_DISCARD

By default, the @emph{perl_call_*} functions place the items returned from
by the Perl subroutine on the stack.  If you are not interested in
these items, then setting this flag will make Perl get rid of them
automatically for you.  Note that it is still possible to indicate a
context to the Perl subroutine by using either G_SCALAR or G_ARRAY.

If you do not set this flag then it is @emph{very} important that you make
sure that any temporaries (i.e. parameters passed to the Perl
subroutine and values returned from the subroutine) are disposed of
yourself.  The section Returning a Scalar gives details of how to
explicitly dispose of these temporaries and the section @emph{Using Perl to
dispose of temporaries} discusses the specific circumstances where you
can ignore the problem and let Perl deal with it for you.

@unnumberedsubsec G_NOARGS

Whenever a Perl subroutine is called using one of the @emph{perl_call_*}
functions, it is assumed by default that parameters are to be passed to
the subroutine.  If you are not passing any parameters to the Perl
subroutine, you can save a bit of time by setting this flag.  It has
the effect of not creating the @code{@@_} array for the Perl subroutine.

Although the functionality provided by this flag may seem
straightforward, it should be used only if there is a good reason to do
so.  The reason for being cautious is that even if you have specified
the G_NOARGS flag, it is still possible for the Perl subroutine that
has been called to think that you have passed it parameters.

In fact, what can happen is that the Perl subroutine you have called
can access the @code{@@_} array from a previous Perl subroutine.  This will
occur when the code that is executing the @emph{perl_call_*} function has
itself been called from another Perl subroutine. The code below
illustrates this

@example
sub fred
  @{ print "@@_\n"  @}
@end example

@example
sub joe
  @{ &fred @}
@end example

@example
&joe(1,2,3) ;
@end example

This will print

@example
1 2 3
@end example

What has happened is that @code{fred} accesses the @code{@@_} array which
belongs to @code{joe}.

@unnumberedsubsec G_EVAL	

It is possible for the Perl subroutine you are calling to terminate
abnormally, e.g. by calling die explicitly or by not actually
existing.  By default, when either of these of events occurs, the
process will terminate immediately.  If though, you want to trap this
type of event, specify the G_EVAL flag.  It will put an @emph{eval @{ @}}
around the subroutine call.

Whenever control returns from the @emph{perl_call_*} function you need to
check the @code{$@@} variable as you would in a normal Perl script.

The value returned from the @emph{perl_call_*} function is dependent on
what other flags have been specified and whether an error has
occurred.  Here are all the different cases that can occur:

@itemize @bullet
@item 
If the @emph{perl_call_*} function returns normally, then the value
returned is as specified in the previous sections.

@item 
If G_DISCARD is specified, the return value will always be 0.

@item 
If G_ARRAY is specified @emph{and} an error has occurred, the return value
will always be 0.

@item 
If G_SCALAR is specified @emph{and} an error has occurred, the return value
will be 1 and the value on the top of the stack will be undef. This
means that if you have already detected the error by checking @code{$@@} and
you want the program to continue, you must remember to pop the undef
from the stack.

@end itemize
See Using G_EVAL for details of using G_EVAL.

@unnumberedsubsec G_KEEPERR

You may have noticed that using the G_EVAL flag described above will
@strong{always} clear the @code{$@@} variable and set it to a string describing
the error iff there was an error in the called code.  This unqualified
resetting of @code{$@@} can be problematic in the reliable identification of
errors using the @code{eval @{@}} mechanism, because the possibility exists
that perl will call other code (end of block processing code, for
example) between the time the error causes @code{$@@} to be set within
@code{eval @{@}}, and the subsequent statement which checks for the value of
@code{$@@} gets executed in the user@'s script.

This scenario will mostly be applicable to code that is meant to be
called from within destructors, asynchronous callbacks, signal
handlers, @code{__DIE__} or @code{__WARN__} hooks, and tie functions.  In
such situations, you will not want to clear @code{$@@} at all, but simply to
append any new errors to any existing value of @code{$@@}.

The G_KEEPERR flag is meant to be used in conjunction with G_EVAL in
@emph{perl_call_*} functions that are used to implement such code.  This flag
has no effect when G_EVAL is not used.

When G_KEEPERR is used, any errors in the called code will be prefixed
with the string "\t(in cleanup)", and appended to the current value
of @code{$@@}.

The G_KEEPERR flag was introduced in Perl version 5.002.

See Using G_KEEPERR for an example of a situation that warrants the
use of this flag.

@unnumberedsubsec Determining the Context 

As mentioned above, you can determine the context of the currently
executing subroutine in Perl with wantarray. The equivalent test can
be made in C by using the GIMME macro. This will return G_SCALAR
if you have been called in a scalar context and G_ARRAY if in an
array context. An example of using the GIMME macro is shown in
section Using GIMME.

@unnumberedsec KNOWN PROBLEMS

This section outlines all known problems that exist in the
@emph{perl_call_*} functions.

@enumerate
@item 
If you are intending to make use of both the G_EVAL and G_SCALAR flags
in your code, use a version of Perl greater than 5.000.  There is a bug
in version 5.000 of Perl which means that the combination of these two
flags will not work as described in the section FLAG VALUES.

Specifically, if the two flags are used when calling a subroutine and
that subroutine does not call die, the value returned by
@emph{perl_call_*} will be wrong.

@item 
In Perl 5.000 and 5.001 there is a problem with using @emph{perl_call_*} if
the Perl sub you are calling attempts to trap a die.

The symptom of this problem is that the called Perl sub will continue
to completion, but whenever it attempts to pass control back to the
XSUB, the program will immediately terminate.

For example, say you want to call this Perl sub

@example
sub fred
@{
    eval @{ die "Fatal Error" ; @}
    print "Trapped error: $@@\n" 
        if $@@ ;
@}
@end example

via this XSUB

@example
void
Call_fred()
    CODE:
    PUSHMARK(sp) ;
    perl_call_pv("fred", G_DISCARD|G_NOARGS) ;
    fprintf(stderr, "back in Call_fred\n") ;
@end example

When @code{Call_fred} is executed it will print

@example
Trapped error: Fatal Error
@end example

As control never returns to @code{Call_fred}, the @code{"back in Call_fred"}
string will not get printed.

To work around this problem, you can either upgrade to Perl 5.002 (or
later), or use the G_EVAL flag with @emph{perl_call_*} as shown below

@example
void
Call_fred()
    CODE:
    PUSHMARK(sp) ;
    perl_call_pv("fred", G_EVAL|G_DISCARD|G_NOARGS) ;
    fprintf(stderr, "back in Call_fred\n") ;
@end example

@end enumerate
@unnumberedsec EXAMPLES

Enough of the definition talk, let@'s have a few examples.

Perl provides many macros to assist in accessing the Perl stack.
Wherever possible, these macros should always be used when interfacing
to Perl internals.  Hopefully this should make the code less vulnerable
to any changes made to Perl in the future.

Another point worth noting is that in the first series of examples I
have made use of only the perl_call_pv function.  This has been done
to keep the code simpler and ease you into the topic.  Wherever
possible, if the choice is between using perl_call_pv and
perl_call_sv, you should always try to use perl_call_sv.  See
Using perl_call_sv for details.

@unnumberedsubsec No Parameters, Nothing returned

This first trivial example will call a Perl subroutine, @emph{PrintUID}, to
print out the UID of the process.

@example
sub PrintUID
@{
    print "UID is $<\n" ;
@}
@end example

and here is a C function to call it

@example
static void
call_PrintUID()
@{
    dSP ;
@end example

@example
PUSHMARK(sp) ;
perl_call_pv("PrintUID", G_DISCARD|G_NOARGS) ;
    @}
@end example

Simple, eh.

A few points to note about this example.

@enumerate
@item 
Ignore dSP and @code{PUSHMARK(sp)} for now. They will be discussed in
the next example.

@item 
We aren@'t passing any parameters to @emph{PrintUID} so G_NOARGS can be
specified.

@item 
We aren@'t interested in anything returned from @emph{PrintUID}, so
G_DISCARD is specified. Even if @emph{PrintUID} was changed to actually
return some value(s), having specified G_DISCARD will mean that they
will be wiped by the time control returns from perl_call_pv.

@item 
As perl_call_pv is being used, the Perl subroutine is specified as a
C string. In this case the subroutine name has been @'hard-wired@' into the
code.

@item 
Because we specified G_DISCARD, it is not necessary to check the value
returned from perl_call_pv. It will always be 0.

@end enumerate
@unnumberedsubsec Passing Parameters

Now let@'s make a slightly more complex example. This time we want to
call a Perl subroutine, @code{LeftString}, which will take 2 parameters - a
string ($s) and an integer ($n).  The subroutine will simply
print the first $n characters of the string.

So the Perl subroutine would look like this

@example
sub LeftString
@{
    my($s, $n) = @@_ ;
    print substr($s, 0, $n), "\n" ;
@}
@end example

The C function required to call @emph{LeftString} would look like this.

@example
static void
call_LeftString(a, b)
char * a ;
int b ;
@{
    dSP ;
@end example

@example
PUSHMARK(sp) ;
XPUSHs(sv_2mortal(newSVpv(a, 0)));
XPUSHs(sv_2mortal(newSViv(b)));
PUTBACK ;
@end example

@example
perl_call_pv("LeftString", G_DISCARD);
    @}
@end example

Here are a few notes on the C function @emph{call_LeftString}.

@enumerate
@item 
Parameters are passed to the Perl subroutine using the Perl stack.
This is the purpose of the code beginning with the line dSP and
ending with the line PUTBACK.

@item 
If you are going to put something onto the Perl stack, you need to know
where to put it. This is the purpose of the macro dSP - it declares
and initializes a local copy of the Perl stack pointer.

All the other macros which will be used in this example require you to
have used this macro.

The exception to this rule is if you are calling a Perl subroutine
directly from an XSUB function. In this case it is not necessary to
explicitly use the dSP macro - it will be declared for you
automatically.

@item 
Any parameters to be pushed onto the stack should be bracketed by the
PUSHMARK and PUTBACK macros.  The purpose of these two macros, in
this context, is to automatically count the number of parameters you
are pushing. Then whenever Perl is creating the @code{@@_} array for the
subroutine, it knows how big to make it.

The PUSHMARK macro tells Perl to make a mental note of the current
stack pointer. Even if you aren@'t passing any parameters (like the
example shown in the section No Parameters, Nothing returned) you
must still call the PUSHMARK macro before you can call any of the
@emph{perl_call_*} functions - Perl still needs to know that there are no
parameters.

The PUTBACK macro sets the global copy of the stack pointer to be
the same as our local copy. If we didn@'t do this perl_call_pv
wouldn@'t know where the two parameters we pushed were - remember that
up to now all the stack pointer manipulation we have done is with our
local copy, @emph{not} the global copy.

@item 
The only flag specified this time is G_DISCARD. Since we are passing 2
parameters to the Perl subroutine this time, we have not specified
G_NOARGS.

@item 
Next, we come to XPUSHs. This is where the parameters actually get
pushed onto the stack. In this case we are pushing a string and an
integer.

See the @samp{"XSUBs and the Argument Stack"}, @xref{perlguts,Perlguts}, for details
on how the XPUSH macros work.

@item 
Finally, @emph{LeftString} can now be called via the perl_call_pv
function.

@end enumerate
@unnumberedsubsec Returning a Scalar

Now for an example of dealing with the items returned from a Perl
subroutine.

Here is a Perl subroutine, @emph{Adder},  which takes 2 integer parameters
and simply returns their sum.

@example
sub Adder
@{
    my($a, $b) = @@_ ;
    $a + $b ;
@}
@end example

Since we are now concerned with the return value from @emph{Adder}, the C
function required to call it is now a bit more complex.

@example
static void
call_Adder(a, b)
int a ;
int b ;
@{
    dSP ;
    int count ;
@end example

@example
ENTER ;
SAVETMPS;
@end example

@example
PUSHMARK(sp) ;
XPUSHs(sv_2mortal(newSViv(a)));
XPUSHs(sv_2mortal(newSViv(b)));
PUTBACK ;
@end example

@example
count = perl_call_pv("Adder", G_SCALAR);
@end example

@example
SPAGAIN ;
@end example

@example
if (count != 1)
    croak("Big trouble\n") ;
@end example

@example
printf ("The sum of %d and %d is %d\n", a, b, POPi) ;
@end example

@example
PUTBACK ;
FREETMPS ;
LEAVE ;
    @}
@end example

Points to note this time are

@enumerate
@item 
The only flag specified this time was G_SCALAR. That means the @code{@@_}
array will be created and that the value returned by @emph{Adder} will
still exist after the call to perl_call_pv.

@item 
Because we are interested in what is returned from @emph{Adder} we cannot
specify G_DISCARD. This means that we will have to tidy up the Perl
stack and dispose of any temporary values ourselves. This is the
purpose of

@example
ENTER ;
SAVETMPS ;
@end example

at the start of the function, and

@example
FREETMPS ;
LEAVE ;
@end example

at the end. The ENTER/SAVETMPS pair creates a boundary for any
temporaries we create.  This means that the temporaries we get rid of
will be limited to those which were created after these calls.

The FREETMPS/LEAVE pair will get rid of any values returned by
the Perl subroutine, plus it will also dump the mortal SV@'s we have
created.  Having ENTER/SAVETMPS at the beginning of the code
makes sure that no other mortals are destroyed.

Think of these macros as working a bit like using @code{@{} and @code{@}} in Perl
to limit the scope of local variables.

See the section Using Perl to dispose of temporaries for details of
an alternative to using these macros.

@item 
The purpose of the macro SPAGAIN is to refresh the local copy of the
stack pointer. This is necessary because it is possible that the memory
allocated to the Perl stack has been re-allocated whilst in the
perl_call_pv call.

If you are making use of the Perl stack pointer in your code you must
always refresh the your local copy using SPAGAIN whenever you make use
of the @emph{perl_call_*} functions or any other Perl internal function.

@item 
Although only a single value was expected to be returned from @emph{Adder},
it is still good practice to check the return code from perl_call_pv
anyway.

Expecting a single value is not quite the same as knowing that there
will be one. If someone modified @emph{Adder} to return a list and we
didn@'t check for that possibility and take appropriate action the Perl
stack would end up in an inconsistent state. That is something you
@emph{really} don@'t want to ever happen.

@item 
The POPi macro is used here to pop the return value from the stack.
In this case we wanted an integer, so POPi was used.

Here is the complete list of POP macros available, along with the types
they return.

@example
POPs	SV
POPp	pointer
POPn	double
POPi	integer
POPl	long
@end example

@item 
The final PUTBACK is used to leave the Perl stack in a consistent
state before exiting the function.  This is necessary because when we
popped the return value from the stack with POPi it updated only our
local copy of the stack pointer.  Remember, PUTBACK sets the global
stack pointer to be the same as our local copy.

@end enumerate
@unnumberedsubsec Returning a list of values

Now, let@'s extend the previous example to return both the sum of the
parameters and the difference.

Here is the Perl subroutine

@example
sub AddSubtract
@{
   my($a, $b) = @@_ ;
   ($a+$b, $a-$b) ;
@}
@end example

and this is the C function

@example
static void
call_AddSubtract(a, b)
int a ;
int b ;
@{
    dSP ;
    int count ;
@end example

@example
ENTER ;
SAVETMPS;
@end example

@example
PUSHMARK(sp) ;
XPUSHs(sv_2mortal(newSViv(a)));
XPUSHs(sv_2mortal(newSViv(b)));
PUTBACK ;
@end example

@example
count = perl_call_pv("AddSubtract", G_ARRAY);
@end example

@example
SPAGAIN ;
@end example

@example
if (count != 2)
    croak("Big trouble\n") ;
@end example

@example
printf ("%d - %d = %d\n", a, b, POPi) ;
printf ("%d + %d = %d\n", a, b, POPi) ;
@end example

@example
PUTBACK ;
FREETMPS ;
LEAVE ;
    @}
@end example

If @emph{call_AddSubtract} is called like this

@example
call_AddSubtract(7, 4) ;
@end example

then here is the output

@example
7 - 4 = 3
7 + 4 = 11
@end example

Notes

@enumerate
@item 
We wanted array context, so G_ARRAY was used.

@item 
Not surprisingly POPi is used twice this time because we were
retrieving 2 values from the stack. The important thing to note is that
when using the @code{POP*} macros they come off the stack in reverse
order.

@end enumerate
@unnumberedsubsec Returning a list in a scalar context

Say the Perl subroutine in the previous section was called in a scalar
context, like this

@example
static void
call_AddSubScalar(a, b)
int a ;
int b ;
@{
    dSP ;
    int count ;
    int i ;
@end example

@example
ENTER ;
SAVETMPS;
@end example

@example
PUSHMARK(sp) ;
XPUSHs(sv_2mortal(newSViv(a)));
XPUSHs(sv_2mortal(newSViv(b)));
PUTBACK ;
@end example

@example
count = perl_call_pv("AddSubtract", G_SCALAR);
@end example

@example
SPAGAIN ;
@end example

@example
printf ("Items Returned = %d\n", count) ;
@end example

@example
for (i = 1 ; i <= count ; ++i)
    printf ("Value %d = %d\n", i, POPi) ;
@end example

@example
PUTBACK ;
FREETMPS ;
LEAVE ;
    @}
@end example

The other modification made is that @emph{call_AddSubScalar} will print the
number of items returned from the Perl subroutine and their value (for
simplicity it assumes that they are integer).  So if
@emph{call_AddSubScalar} is called

@example
call_AddSubScalar(7, 4) ;
@end example

then the output will be

@example
Items Returned = 1
Value 1 = 3
@end example

In this case the main point to note is that only the last item in the
list returned from the subroutine, @emph{Adder} actually made it back to
@emph{call_AddSubScalar}.

@unnumberedsubsec Returning Data from Perl via the parameter list

It is also possible to return values directly via the parameter list -
whether it is actually desirable to do it is another matter entirely.

The Perl subroutine, @emph{Inc}, below takes 2 parameters and increments
each directly.

@example
sub Inc
@{
    ++ $_[0] ;
    ++ $_[1] ;
@}
@end example

and here is a C function to call it.

@example
static void
call_Inc(a, b)
int a ;
int b ;
@{
    dSP ;
    int count ;
    SV * sva ;
    SV * svb ;
@end example

@example
ENTER ;
SAVETMPS;
@end example

@example
sva = sv_2mortal(newSViv(a)) ;
svb = sv_2mortal(newSViv(b)) ;
@end example

@example
PUSHMARK(sp) ;
XPUSHs(sva);
XPUSHs(svb);
PUTBACK ;
@end example

@example
count = perl_call_pv("Inc", G_DISCARD);
@end example

@example
if (count != 0)
    croak ("call_Inc: expected 0 values from @'Inc@', got %d\n",
           count) ;
@end example

@example
printf ("%d + 1 = %d\n", a, SvIV(sva)) ;
printf ("%d + 1 = %d\n", b, SvIV(svb)) ;
@end example

@example
FREETMPS ;
        LEAVE ;
    @}
@end example

To be able to access the two parameters that were pushed onto the stack
after they return from perl_call_pv it is necessary to make a note
of their addresses - thus the two variables @code{sva} and @code{svb}.

The reason this is necessary is that the area of the Perl stack which
held them will very likely have been overwritten by something else by
the time control returns from perl_call_pv.

@unnumberedsubsec Using G_EVAL

Now an example using G_EVAL. Below is a Perl subroutine which computes
the difference of its 2 parameters. If this would result in a negative
result, the subroutine calls die.

@example
sub Subtract
@{
    my ($a, $b) = @@_ ;
@end example

@example
die "death can be fatal\n" if $a < $b ;
@end example

@example
$a - $b ;
    @}
@end example

and some C to call it

@example
static void
call_Subtract(a, b)
int a ;
int b ;
@{
    dSP ;
    int count ;
@end example

@example
ENTER ;
SAVETMPS;
@end example

@example
PUSHMARK(sp) ;
XPUSHs(sv_2mortal(newSViv(a)));
XPUSHs(sv_2mortal(newSViv(b)));
PUTBACK ;
@end example

@example
count = perl_call_pv("Subtract", G_EVAL|G_SCALAR);
@end example

@example
SPAGAIN ;
@end example

@example
/* Check the eval first */
if (SvTRUE(GvSV(errgv)))
@{
    printf ("Uh oh - %s\n", SvPV(GvSV(errgv), na)) ;
    POPs ;
@}
else
@{
    if (count != 1)
       croak("call_Subtract: wanted 1 value from @'Subtract@', got %d\n",
                count) ;
@end example

@example
printf ("%d - %d = %d\n", a, b, POPi) ;
        @}
@end example

@example
PUTBACK ;
FREETMPS ;
LEAVE ;
    @}
@end example

If @emph{call_Subtract} is called thus

@example
call_Subtract(4, 5)
@end example

the following will be printed

@example
Uh oh - death can be fatal
@end example

Notes

@enumerate
@item 
We want to be able to catch the die so we have used the G_EVAL
flag.  Not specifying this flag would mean that the program would
terminate immediately at the die statement in the subroutine
@emph{Subtract}.

@item 
The code 

@example
if (SvTRUE(GvSV(errgv)))
@{
    printf ("Uh oh - %s\n", SvPV(GvSV(errgv), na)) ;
    POPs ;
@}
@end example

is the direct equivalent of this bit of Perl

@example
print "Uh oh - $@@\n" if $@@ ;
@end example

@code{errgv} is a perl global of type @code{GV *} that points to the
symbol table entry containing the error.  @code{GvSV(errgv)} therefore
refers to the C equivalent of @code{$@@}.

@item 
Note that the stack is popped using POPs in the block where
@code{SvTRUE(GvSV(errgv))} is true.  This is necessary because whenever a
@emph{perl_call_*} function invoked with G_EVAL|G_SCALAR returns an error,
the top of the stack holds the value undef. Since we want the
program to continue after detecting this error, it is essential that
the stack is tidied up by removing the undef.

@end enumerate
@unnumberedsubsec Using G_KEEPERR

Consider this rather facetious example, where we have used an XS
version of the call_Subtract example above inside a destructor:

@example
package Foo;
sub new @{ bless @{@}, $_[0] @}
sub Subtract @{ 
    my($a,$b) = @@_;
    die "death can be fatal" if $a < $b ;
    $a - $b;
@}
sub DESTROY @{ call_Subtract(5, 4); @}
sub foo @{ die "foo dies"; @}
@end example

@example
package main;
eval @{ Foo->new->foo @};
print "Saw: $@@" if $@@;             # should be, but isn@'t
@end example

This example will fail to recognize that an error occurred inside the
@code{eval @{@}}.  Here@'s why: the call_Subtract code got executed while perl
was cleaning up temporaries when exiting the eval block, and since
call_Subtract is implemented with perl_call_pv using the G_EVAL
flag, it promptly reset @code{$@@}.  This results in the failure of the
outermost test for @code{$@@}, and thereby the failure of the error trap.

Appending the G_KEEPERR flag, so that the perl_call_pv call in
call_Subtract reads:

@example
count = perl_call_pv("Subtract", G_EVAL|G_SCALAR|G_KEEPERR);
@end example

will preserve the error and restore reliable error handling.

@unnumberedsubsec Using perl_call_sv

In all the previous examples I have @'hard-wired@' the name of the Perl
subroutine to be called from C.  Most of the time though, it is more
convenient to be able to specify the name of the Perl subroutine from
within the Perl script.

Consider the Perl code below

@example
sub fred
@{
    print "Hello there\n" ;
@}
@end example

@example
CallSubPV("fred") ;
@end example

Here is a snippet of XSUB which defines @emph{CallSubPV}.

@example
void
CallSubPV(name)
	char *	name
	CODE:
	PUSHMARK(sp) ;
	perl_call_pv(name, G_DISCARD|G_NOARGS) ;
@end example

That is fine as far as it goes. The thing is, the Perl subroutine 
can be specified only as a string.  For Perl 4 this was adequate,
but Perl 5 allows references to subroutines and anonymous subroutines.
This is where perl_call_sv is useful.

The code below for @emph{CallSubSV} is identical to @emph{CallSubPV} except
that the @code{name} parameter is now defined as an SV* and we use
perl_call_sv instead of perl_call_pv.

@example
void
CallSubSV(name)
	SV *	name
	CODE:
	PUSHMARK(sp) ;
	perl_call_sv(name, G_DISCARD|G_NOARGS) ;
@end example

Since we are using an SV to call @emph{fred} the following can all be used

@example
CallSubSV("fred") ;
CallSubSV(\&fred) ;
$ref = \&fred ;
CallSubSV($ref) ;
CallSubSV( sub @{ print "Hello there\n" @} ) ;
@end example

As you can see, perl_call_sv gives you much greater flexibility in
how you can specify the Perl subroutine.

You should note that if it is necessary to store the SV (@code{name} in the
example above) which corresponds to the Perl subroutine so that it can
be used later in the program, it not enough to just store a copy of the
pointer to the SV. Say the code above had been like this

@example
static SV * rememberSub ;
@end example

@example
void
SaveSub1(name)
	SV *	name
	CODE:
	rememberSub = name ;
@end example

@example
void
CallSavedSub1()
	CODE:
	PUSHMARK(sp) ;
	perl_call_sv(rememberSub, G_DISCARD|G_NOARGS) ;
@end example

The reason this is wrong is that by the time you come to use the
pointer @code{rememberSub} in @code{CallSavedSub1}, it may or may not still refer
to the Perl subroutine that was recorded in @code{SaveSub1}.  This is
particularly true for these cases

@example
SaveSub1(\&fred) ;
CallSavedSub1() ;
@end example

@example
SaveSub1( sub @{ print "Hello there\n" @} ) ;
CallSavedSub1() ;
@end example

By the time each of the @code{SaveSub1} statements above have been executed,
the SV*@'s which corresponded to the parameters will no longer exist.
Expect an error message from Perl of the form

@example
Can@'t use an undefined value as a subroutine reference at ...
@end example

for each of the @code{CallSavedSub1} lines.

Similarly, with this code 

@example
$ref = \&fred ;
SaveSub1($ref) ;
$ref = 47 ;
CallSavedSub1() ;
@end example

you can expect one of these messages (which you actually get is dependent on 
the version of Perl you are using) 

@example
Not a CODE reference at ...
Undefined subroutine &main::47 called ...
@end example

The variable @code{$ref} may have referred to the subroutine @code{fred}
whenever the call to @code{SaveSub1} was made but by the time
@code{CallSavedSub1} gets called it now holds the number @code{47}. Since we
saved only a pointer to the original SV in @code{SaveSub1}, any changes to
@code{$ref} will be tracked by the pointer @code{rememberSub}. This means that
whenever @code{CallSavedSub1} gets called, it will attempt to execute the
code which is referenced by the SV* @code{rememberSub}.  In this case
though, it now refers to the integer @code{47}, so expect Perl to complain
loudly.

A similar but more subtle problem is illustrated with this code

@example
$ref = \&fred ;
SaveSub1($ref) ;
$ref = \&joe ;
CallSavedSub1() ;
@end example

This time whenever @code{CallSavedSub1} get called it will execute the Perl
subroutine @code{joe} (assuming it exists) rather than @code{fred} as was 
originally requested in the call to @code{SaveSub1}.

To get around these problems it is necessary to take a full copy of the
SV.  The code below shows @code{SaveSub2} modified to do that

@example
static SV * keepSub = (SV*)NULL ;
@end example

@example
void
SaveSub2(name)
    SV *	name
	CODE:
 	/* Take a copy of the callback */
	if (keepSub == (SV*)NULL)
	    /* First time, so create a new SV */
	    keepSub = newSVsv(name) ;
	else
	    /* Been here before, so overwrite */
	    SvSetSV(keepSub, name) ;
@end example

@example
void
CallSavedSub2()
	CODE:
	PUSHMARK(sp) ;
	perl_call_sv(keepSub, G_DISCARD|G_NOARGS) ;
@end example

In order to avoid creating a new SV every time @code{SaveSub2} is called,
the function first checks to see if it has been called before.  If not,
then space for a new SV is allocated and the reference to the Perl
subroutine, @code{name} is copied to the variable @code{keepSub} in one
operation using newSVsv.  Thereafter, whenever @code{SaveSub2} is called
the existing SV, @code{keepSub}, is overwritten with the new value using
@code{SvSetSV}.

@unnumberedsubsec Using perl_call_argv

Here is a Perl subroutine which prints whatever parameters are passed
to it.

@example
sub PrintList
@{
    my(@@list) = @@_ ;
@end example

@example
foreach (@@list) @{ print "$_\n" @}
    @}
@end example

and here is an example of perl_call_argv which will call
@emph{PrintList}.

@example
static char * words[] = @{"alpha", "beta", "gamma", "delta", NULL@} ;
@end example

@example
static void
call_PrintList()
@{
    dSP ;
@end example

@example
perl_call_argv("PrintList", G_DISCARD, words) ;
    @}
@end example

Note that it is not necessary to call PUSHMARK in this instance.
This is because perl_call_argv will do it for you.

@unnumberedsubsec Using perl_call_method

Consider the following Perl code

@example
@{
    package Mine ;
@end example

@example
sub new
@{
    my($type) = shift ;
    bless [@@_]
@}
@end example

@example
sub Display
@{
    my ($self, $index) = @@_ ;
    print "$index: $$self[$index]\n" ;
@}
@end example

@example
sub PrintID
@{
    my($class) = @@_ ;
    print "This is Class $class version 1.0\n" ;
@}
    @}
@end example

It just implements a very simple class to manage an array.  Apart from
the constructor, new, it declares methods, one static and one
virtual. The static method, @code{PrintID}, simply prints out the class
name and a version number. The virtual method, @code{Display}, prints out a
single element of the array.  Here is an all Perl example of using it.

@example
$a = new Mine (@'red@', @'green@', @'blue@') ;
$a->Display(1) ;
PrintID Mine;
@end example

will print

@example
1: green
This is Class Mine version 1.0 
@end example

Calling a Perl method from C is fairly straightforward. The following
things are required

@itemize @bullet
@item 
a reference to the object for a virtual method or the name of the class
for a static method.

@item 
the name of the method.

@item 
any other parameters specific to the method.

@end itemize
Here is a simple XSUB which illustrates the mechanics of calling both
the @code{PrintID} and @code{Display} methods from C.

@example
void
call_Method(ref, method, index)
    SV *	ref
    char *	method
    int		index
    CODE:
    PUSHMARK(sp);
    XPUSHs(ref);
    XPUSHs(sv_2mortal(newSViv(index))) ;
    PUTBACK;
@end example

@example
perl_call_method(method, G_DISCARD) ;
@end example

@example
void
call_PrintID(class, method)
    char *	class
    char *	method
    CODE:
    PUSHMARK(sp);
    XPUSHs(sv_2mortal(newSVpv(class, 0))) ;
    PUTBACK;
@end example

@example
perl_call_method(method, G_DISCARD) ;
@end example

So the methods @code{PrintID} and @code{Display} can be invoked like this

@example
$a = new Mine (@'red@', @'green@', @'blue@') ;
call_Method($a, @'Display@', 1) ;
call_PrintID(@'Mine@', @'PrintID@') ;
@end example

The only thing to note is that in both the static and virtual methods,
the method name is not passed via the stack - it is used as the first
parameter to perl_call_method.

@unnumberedsubsec Using GIMME

Here is a trivial XSUB which prints the context in which it is 
currently executing.

@example
void
PrintContext()
    CODE:
    if (GIMME == G_SCALAR)
        printf ("Context is Scalar\n") ;
    else
        printf ("Context is Array\n") ;
@end example

and here is some Perl to test it

@example
$a = PrintContext ;
@@a = PrintContext ;
@end example

The output from that will be

@example
Context is Scalar
Context is Array
@end example

@unnumberedsubsec Using Perl to dispose of temporaries

In the examples given to date, any temporaries created in the callback
(i.e. parameters passed on the stack to the @emph{perl_call_*} function or
values returned via the stack) have been freed by one of these methods

@itemize @bullet
@item 
specifying the G_DISCARD flag with @emph{perl_call_*}.

@item 
explicitly disposed of using the ENTER/SAVETMPS -
FREETMPS/LEAVE pairing.

@end itemize
There is another method which can be used, namely letting Perl do it
for you automatically whenever it regains control after the callback
has terminated.  This is done by simply not using the

@example
ENTER ;
SAVETMPS ;
...
FREETMPS ;
LEAVE ;
@end example

sequence in the callback (and not, of course, specifying the G_DISCARD
flag).

If you are going to use this method you have to be aware of a possible
memory leak which can arise under very specific circumstances.  To
explain these circumstances you need to know a bit about the flow of
control between Perl and the callback routine.

The examples given at the start of the document (an error handler and
an event driven program) are typical of the two main sorts of flow
control that you are likely to encounter with callbacks.  There is a
very important distinction between them, so pay attention.

In the first example, an error handler, the flow of control could be as
follows.  You have created an interface to an external library.
Control can reach the external library like this

@example
perl --> XSUB --> external library
@end example

Whilst control is in the library, an error condition occurs. You have
previously set up a Perl callback to handle this situation, so it will
get executed. Once the callback has finished, control will drop back to
Perl again.  Here is what the flow of control will be like in that
situation

@example
perl --> XSUB --> external library
                  ...
                  error occurs
                  ...
                  external library --> perl_call --> perl
                                                      |
perl <-- XSUB <-- external library <-- perl_call <----+
@end example

After processing of the error using @emph{perl_call_*} is completed,
control reverts back to Perl more or less immediately.

In the diagram, the further right you go the more deeply nested the
scope is.  It is only when control is back with perl on the extreme
left of the diagram that you will have dropped back to the enclosing
scope and any temporaries you have left hanging around will be freed.

In the second example, an event driven program, the flow of control
will be more like this

@example
perl --> XSUB --> event handler
                  ...
                  event handler --> perl_call --> perl 
                                                   |
                  event handler <-- perl_call --<--+
                  ...
                  event handler --> perl_call --> perl 
                                                   |
                  event handler <-- perl_call --<--+
                  ...
                  event handler --> perl_call --> perl 
                                                   |
                  event handler <-- perl_call --<--+
@end example

In this case the flow of control can consist of only the repeated
sequence

@example
event handler --> perl_call --> perl
@end example

for the practically the complete duration of the program.  This means
that control may @emph{never} drop back to the surrounding scope in Perl at
the extreme left.

So what is the big problem? Well, if you are expecting Perl to tidy up
those temporaries for you, you might be in for a long wait.  For Perl
to actually dispose of your temporaries, control must drop back to the
enclosing scope at some stage.  In the event driven scenario that may
never happen.  This means that as time goes on, your program will
create more and more temporaries, none of which will ever be freed. As
each of these temporaries consumes some memory your program will
eventually consume all the available memory in your system - kapow!

So here is the bottom line - if you are sure that control will revert
back to the enclosing Perl scope fairly quickly after the end of your
callback, then it isn@'t absolutely necessary to explicitly dispose of
any temporaries you may have created. Mind you, if you are at all
uncertain about what to do, it doesn@'t do any harm to tidy up anyway.

@unnumberedsubsec Strategies for storing Callback Context Information

Potentially one of the trickiest problems to overcome when designing a
callback interface can be figuring out how to store the mapping between
the C callback function and the Perl equivalent.

To help understand why this can be a real problem first consider how a
callback is set up in an all C environment.  Typically a C API will
provide a function to register a callback.  This will expect a pointer
to a function as one of its parameters.  Below is a call to a
hypothetical function @code{register_fatal} which registers the C function
to get called when a fatal error occurs.

@example
register_fatal(cb1) ;
@end example

The single parameter @code{cb1} is a pointer to a function, so you must
have defined @code{cb1} in your code, say something like this

@example
static void
cb1()
@{
    printf ("Fatal Error\n") ;
    exit(1) ;
@}
@end example

Now change that to call a Perl subroutine instead

@example
static SV * callback = (SV*)NULL;
@end example

@example
static void
cb1()
@{
    dSP ;
@end example

@example
PUSHMARK(sp) ;
@end example

@example
/* Call the Perl sub to process the callback */
perl_call_sv(callback, G_DISCARD) ;
    @}
@end example

@example
void
register_fatal(fn)
    SV *	fn
    CODE:
    /* Remember the Perl sub */
    if (callback == (SV*)NULL)
        callback = newSVsv(fn) ;
    else
        SvSetSV(callback, fn) ;
@end example

@example
/* register the callback with the external library */
register_fatal(cb1) ;
@end example

where the Perl equivalent of @code{register_fatal} and the callback it
registers, @code{pcb1}, might look like this

@example
# Register the sub pcb1
register_fatal(\&pcb1) ;
@end example

@example
sub pcb1
@{
    die "I@'m dying...\n" ;
@}
@end example

The mapping between the C callback and the Perl equivalent is stored in
the global variable @code{callback}.

This will be adequate if you ever need to have only 1 callback
registered at any time. An example could be an error handler like the
code sketched out above. Remember though, repeated calls to
@code{register_fatal} will replace the previously registered callback
function with the new one.

Say for example you want to interface to a library which allows asynchronous
file i/o.  In this case you may be able to register a callback whenever
a read operation has completed. To be of any use we want to be able to
call separate Perl subroutines for each file that is opened.  As it
stands, the error handler example above would not be adequate as it
allows only a single callback to be defined at any time. What we
require is a means of storing the mapping between the opened file and
the Perl subroutine we want to be called for that file.

Say the i/o library has a function @code{asynch_read} which associates a C
function @code{ProcessRead} with a file handle @code{fh} - this assumes that it
has also provided some routine to open the file and so obtain the file
handle.

@example
asynch_read(fh, ProcessRead)
@end example

This may expect the C @emph{ProcessRead} function of this form

@example
void
ProcessRead(fh, buffer)
int	fh ;
char *	buffer ;
@{
     ... 
@}
@end example

To provide a Perl interface to this library we need to be able to map
between the @code{fh} parameter and the Perl subroutine we want called.  A
hash is a convenient mechanism for storing this mapping.  The code
below shows a possible implementation

@example
static HV * Mapping = (HV*)NULL ;
@end example

@example
void
asynch_read(fh, callback)
    int	fh
    SV *	callback
    CODE:
    /* If the hash doesn@'t already exist, create it */
    if (Mapping == (HV*)NULL)
        Mapping = newHV() ;
@end example

@example
/* Save the fh -> callback mapping */
hv_store(Mapping, (char*)&fh, sizeof(fh), newSVsv(callback), 0) ;
@end example

@example
/* Register with the C Library */
asynch_read(fh, asynch_read_if) ;
@end example

and @code{asynch_read_if} could look like this

@example
static void
asynch_read_if(fh, buffer)
int	fh ;
char *	buffer ;
@{
    dSP ;
    SV ** sv ;
@end example

@example
/* Get the callback associated with fh */
sv =  hv_fetch(Mapping, (char*)&fh , sizeof(fh), FALSE) ;
if (sv == (SV**)NULL)
    croak("Internal error...\n") ;
@end example

@example
PUSHMARK(sp) ;
XPUSHs(sv_2mortal(newSViv(fh))) ;
XPUSHs(sv_2mortal(newSVpv(buffer, 0))) ;
PUTBACK ;
@end example

@example
/* Call the Perl sub */
perl_call_sv(*sv, G_DISCARD) ;
    @}
@end example

For completeness, here is @code{asynch_close}.  This shows how to remove
the entry from the hash @code{Mapping}.

@example
void
asynch_close(fh)
    int	fh
    CODE:
    /* Remove the entry from the hash */
    (void) hv_delete(Mapping, (char*)&fh, sizeof(fh), G_DISCARD) ;
@end example

@example
/* Now call the real asynch_close */
asynch_close(fh) ;
@end example

So the Perl interface would look like this

@example
sub callback1
@{
    my($handle, $buffer) = @@_ ;
@}
@end example

@example
# Register the Perl callback
asynch_read($fh, \&callback1) ;
@end example

@example
asynch_close($fh) ;
@end example

The mapping between the C callback and Perl is stored in the global
hash @code{Mapping} this time. Using a hash has the distinct advantage that
it allows an unlimited number of callbacks to be registered.

What if the interface provided by the C callback doesn@'t contain a
parameter which allows the file handle to Perl subroutine mapping?  Say
in the asynchronous i/o package, the callback function gets passed only
the @code{buffer} parameter like this

@example
void
ProcessRead(buffer)
char *	buffer ;
@{
    ...
@}
@end example

Without the file handle there is no straightforward way to map from the
C callback to the Perl subroutine.

In this case a possible way around this problem is to pre-define a
series of C functions to act as the interface to Perl, thus

@example
#define MAX_CB		3
#define NULL_HANDLE	-1
typedef void (*FnMap)() ;
@end example

@example
struct MapStruct @{
    FnMap    Function ;
    SV *     PerlSub ;
    int      Handle ;
  @} ;
@end example

@example
static void  fn1() ;
static void  fn2() ;
static void  fn3() ;
@end example

@example
static struct MapStruct Map [MAX_CB] =
    @{
        @{ fn1, NULL, NULL_HANDLE @},
        @{ fn2, NULL, NULL_HANDLE @},
        @{ fn3, NULL, NULL_HANDLE @}
    @} ;
@end example

@example
static void
Pcb(index, buffer)
int index ;
char * buffer ;
@{
    dSP ;
@end example

@example
PUSHMARK(sp) ;
XPUSHs(sv_2mortal(newSVpv(buffer, 0))) ;
PUTBACK ;
@end example

@example
/* Call the Perl sub */
perl_call_sv(Map[index].PerlSub, G_DISCARD) ;
    @}
@end example

@example
static void
fn1(buffer)
char * buffer ;
@{
    Pcb(0, buffer) ;
@}
@end example

@example
static void
fn2(buffer)
char * buffer ;
@{
    Pcb(1, buffer) ;
@}
@end example

@example
static void
fn3(buffer)
char * buffer ;
@{
    Pcb(2, buffer) ;
@}
@end example

@example
void
array_asynch_read(fh, callback)
    int		fh
    SV *	callback
    CODE:
    int index ;
    int null_index = MAX_CB ;
@end example

@example
/* Find the same handle or an empty entry */
for (index = 0 ; index < MAX_CB ; ++index)
@{
    if (Map[index].Handle == fh)
        break ;
@end example

@example
if (Map[index].Handle == NULL_HANDLE)
    null_index = index ;
        @}
@end example

@example
if (index == MAX_CB && null_index == MAX_CB)
    croak ("Too many callback functions registered\n") ;
@end example

@example
if (index == MAX_CB)
    index = null_index ;
@end example

@example
/* Save the file handle */
Map[index].Handle = fh ;
@end example

@example
/* Remember the Perl sub */
if (Map[index].PerlSub == (SV*)NULL)
    Map[index].PerlSub = newSVsv(callback) ;
else
    SvSetSV(Map[index].PerlSub, callback) ;
@end example

@example
asynch_read(fh, Map[index].Function) ;
@end example

@example
void
array_asynch_close(fh)
    int	fh
    CODE:
    int index ;
@end example

@example
/* Find the file handle */
for (index = 0; index < MAX_CB ; ++ index)
    if (Map[index].Handle == fh)
        break ;
@end example

@example
if (index == MAX_CB)
    croak ("could not close fh %d\n", fh) ;
@end example

@example
Map[index].Handle = NULL_HANDLE ;
SvREFCNT_dec(Map[index].PerlSub) ;
Map[index].PerlSub = (SV*)NULL ;
@end example

@example
asynch_close(fh) ;
@end example

In this case the functions @code{fn1}, @code{fn2} and @code{fn3} are used to
remember the Perl subroutine to be called. Each of the functions holds
a separate hard-wired index which is used in the function @code{Pcb} to
access the @code{Map} array and actually call the Perl subroutine.

There are some obvious disadvantages with this technique.

Firstly, the code is considerably more complex than with the previous
example.

Secondly, there is a hard-wired limit (in this case 3) to the number of
callbacks that can exist simultaneously. The only way to increase the
limit is by modifying the code to add more functions and then
re-compiling.  None the less, as long as the number of functions is
chosen with some care, it is still a workable solution and in some
cases is the only one available.

To summarize, here are a number of possible methods for you to consider
for storing the mapping between C and the Perl callback

@enumerate
@item 
Ignore the problem - Allow only 1 callback
For a lot of situations, like interfacing to an error handler, this may
be a perfectly adequate solution.

@item 
Create a sequence of callbacks - hard wired limit
If it is impossible to tell from the parameters passed back from the C
callback what the context is, then you may need to create a sequence of C
callback interface functions, and store pointers to each in an array.

@item 
Use a parameter to map to the Perl callback
A hash is an ideal mechanism to store the mapping between C and Perl.

@end enumerate
@unnumberedsubsec Alternate Stack Manipulation

Although I have made use of only the @code{POP*} macros to access values
returned from Perl subroutines, it is also possible to bypass these
macros and read the stack using the ST macro (See @xref{perlxs,Perlxs}, for a
full description of the ST macro).

Most of the time the @code{POP*} macros should be adequate, the main
problem with them is that they force you to process the returned values
in sequence. This may not be the most suitable way to process the
values in some cases. What we want is to be able to access the stack in
a random order. The ST macro as used when coding an XSUB is ideal
for this purpose.

The code below is the example given in the section @emph{Returning a list
of values} recoded to use ST instead of @code{POP*}.

@example
static void
call_AddSubtract2(a, b)
int a ;
int b ;
@{
    dSP ;
    I32 ax ;
    int count ;
@end example

@example
ENTER ;
SAVETMPS;
@end example

@example
PUSHMARK(sp) ;
XPUSHs(sv_2mortal(newSViv(a)));
XPUSHs(sv_2mortal(newSViv(b)));
PUTBACK ;
@end example

@example
count = perl_call_pv("AddSubtract", G_ARRAY);
@end example

@example
SPAGAIN ;
sp -= count ;
ax = (sp - stack_base) + 1 ;
@end example

@example
if (count != 2)
    croak("Big trouble\n") ;
@end example

@example
printf ("%d + %d = %d\n", a, b, SvIV(ST(0))) ;
printf ("%d - %d = %d\n", a, b, SvIV(ST(1))) ;
@end example

@example
PUTBACK ;
FREETMPS ;
LEAVE ;
    @}
@end example

Notes

@enumerate
@item 
Notice that it was necessary to define the variable @code{ax}.  This is
because the ST macro expects it to exist.  If we were in an XSUB it
would not be necessary to define @code{ax} as it is already defined for
you.

@item 
The code

@example
SPAGAIN ;
sp -= count ;
ax = (sp - stack_base) + 1 ;
@end example

sets the stack up so that we can use the ST macro.

@item 
Unlike the original coding of this example, the returned
values are not accessed in reverse order.  So @code{ST(0)} refers to the
first value returned by the Perl subroutine and @code{ST(count-1)} 
refers to the last.

@end enumerate
@unnumberedsec SEE ALSO

@xref{perlxs,Perlxs},, @xref{perlguts,Perlguts},, @xref{perlembed,Perlembed},

@unnumberedsec AUTHOR

Paul Marquess <@file{pmarquess@@bfsec.bt.co.uk}>

Special thanks to the following people who assisted in the creation of
the document.

Jeff Okamoto, Tim Bunce, Nick Gianniotis, Steve Kelem, Gurusamy Sarathy
and Larry Wall.

@unnumberedsec DATE

Version 1.2, 16th Jan 1996
